# 上下文切换

## 定义

CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到在加载的过程就是一次上下文切换。



## 减少上下文切换的方法

1、**无锁并发编程**

​							如将数据ID按照Hash算法取模分段，不同线程处理不同段的数据

2、**CAS算法**

​							 JAVA的Atomic包使用CAS算法来更新数据，而不需要加锁

3、**使用最少线程**

​							 避免创建不需要的线程



## 死锁避免方法

1、避免一个线程同时获取多个锁

2、避免一个线程在所内同时占用多个资源，尽量保证每个锁只占用一个资源

3、使用定时锁，使用lock.tryLock(timeout)来代替内部锁机制

4、对于数据库锁，加锁和解锁必须在一个数据库链接里，否则会出现解锁失败的情况







| 一般非数组对象 | 8个字节对象头(mark) + 4/8字节对象指针 + 数据区 + padding内存对齐(按照8的倍数对齐) |
| :------------- | ------------------------------------------------------------ |
| 数组对象       | 8个字节对象头(mark) + 4/8字节对象指针 + 4字节数组长度 + 数据区 + padding内存对齐(按照8的倍数对齐) |







# 缓存一致性协议

就是多个CPU核心中缓存的同一共享数据的数据一致



# Volatile

## 定义

JAVA编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排它锁



## 特点

可见性

不具有原子性

禁止指令重排序



## 内存语义

写的内存语义

​	当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主存

读的内存语义

​	当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主存中读取共享变量



## 内存语义的实现

保守策略屏障：

​	在每个volatile读操作后面插入一个LoadLoad屏障和LoadStore屏障

```
	前者禁止下面的所有普通读操作和上面的volatile读重排序
	后者禁止下面的所有普通写操作和上面的volatile读重排序
```

​	在每个volatile写操作前面插入StoreStore屏障，后面插入StoreLoad屏障

```
	前者禁止上面的普通写     跟下面的volatile写重排序
	后者禁止上面的volatile写跟下面的volatile读/写重排序
```

​	

# Synchronized

## 与Volatile区别

volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性

synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的**可见性和排他性**



## 实现

 JVM基于进入和退出监视器对象实现方法同步和代码块同步

monitorenter是编译后插入到同步代码块的开始位置，monitorexit是插入到方法结束处和异常处



## 作用

（1）线程互斥访问同步代码

（2）可见性

-----没有禁止重排序



## 表现

[三种表现详解](https://www.iteye.com/blog/topmanopensource-1738178)

1.对应普通同步方法，锁是当前实例对象

2.对与静态同步方法，锁是当前类的class对象

3.对于同步方法块，锁是Synchonized括号里的配置对象



## 状态

**偏向锁**

​       是指同一代码块一直被同一个线程访问，那么该线程会自动获取锁，降低获取锁的代价。

​	  检查锁对象头的mark word是否是可偏向状态，然后检查mark word中的线程id是否是自己的id，如果是则执行同步代码，如果不是则cas修改其id，如果修改失败，则出现锁争用，偏向锁失效，膨胀为轻量级锁。  





**轻量级锁**

​      是指锁是偏向锁时，被另一个线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式获取锁，不会阻塞，提高性能。

​	  当一个线程需要获得该对象锁时，线程有一段空间叫做lock record，用于存储对象头的mark word，然后通过cas操作将锁对象头的mark word改成指向线程中的lock record。如果成功了就是获取到了锁，否则就是发生了互斥，继续自旋







**重量级锁**

​     是指锁是轻量级锁时，另一个线程虽然是自旋，但是自旋并不会持续下去，当自旋到一定次数的时候，还没有获取到锁，就会进入阻塞态，该锁升级为重量级锁，重量级锁会让其他申请的线程进入阻塞，性能降低。



## 内存语义

释放锁的内存语义

​	释放锁的时候，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。

获得锁的内存语义

​	获得锁的时候，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。



# 原子操作

## 处理器实现原理

1、使用总线锁保证原子性

2、使用缓存锁来保证原子性



总线锁：使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出该信号时候，其他处理器的请求将被阻				塞住，那么该处理器可以独占共享内存

缓存锁：内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作



例外：

当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定



## JAVA实现原理（循环CAS）

### 循环CAS定义

​	CAS，也就是比较并交换，在CAS操作中，涉及到3个值，内存值A，旧值B，更新值C，当且仅当A和B相等的时候才更新C，一般跟死循环一起用



### 原理

​	**自旋CAS实现的基本思路就是循环调用compareAndSet方法直到成功为止，compareAndSet本质是利用处理器提供的CMPXCHG指令实现的**



### 问题

1.ABA问题

​	版本号解决

2.循环时间长开销大

​	自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。

​	解决方法，自适应锁（旋转太多次就进入等待或者睡眠的状态）

​	JVM能支持处理器提供的pause指令

（1.延迟流水线执行指令，2.避免在推出循环的时候因内存顺序冲突而引起CPU流水线被清空）

3.只能保证一个共享变量的原子操作

​	解决方法：1.把多个共享变量合并成一个共享变量来操作，然后使用AtomicReference

​					    2.使用锁机制实现原子操作(note:JVM实现锁的方式都用了循环CAS)



# final域的内存语义

## 规则

在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序，在return前插入一个StoreStore屏障实现的

初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序，在读final域操作的前面插入一个LoadLoad屏障




