# 异或=无进位相加

0^N=N

N^N=0

满足交换律和结合律

警惕同样的位置，如果用异或来交换数，那么会导致最后出现错误



- 如果数组中只有一种数出现奇数次，其他的出现了偶数次，那么将数组异或就会得到那个奇数次的数

- 如果数组中有两种数出现奇数次，其他的出现了偶数次

- 如何取出一个数最右端的1：

  a^[a&(a-1)],因为a&(a-1)就相当于抹除了a最右端的1，然后再异或a就相当于得到最右边的1

  a&(~a+1),因为~a就是把所有的1变为0，把0变为1，那么+1就会不断进位得到a最右边的1，因为1左边的数与a对应位置不同，所以位与为0，1右边又全是0，位与还是0，最后就会得到那个1



# 主定理

T(N) = a*T(N/b) + O(N^d)
1) log(b,a) > d -> 复杂度为O(N^log(b,a))
2) log(b,a) = d -> 复杂度为O(N^d * logN)
3) log(b,a) < d -> 复杂度为O(N^d)



插入排序等是因为大量浪费比较行为，

归并，当有比较行为的时候信息留下来了，变成了排好序的部分



# 堆排序

堆，插入要扩容logN次，加单个数代价是O(NlogN)

在Java里面PriorityQueue<Integer> heap  = new PriorityQueue<>();默认是小根堆

如果要用大顶堆，就要用以下的比较器



```java
PriorityQueue<Integer> heap  = new PriorityQueue<>(new newComparator());
private class newComparator implements Comparator<Integer>{
        /**
         *  比较器
         *  返回负数，则前面的数排前面
         *  返回正数，则后面的数排前面
         *  返回0，则无所谓
         */
        @Override
        public int compare(Integer o1, Integer o2) {
            return o1-o2;
        }
    }
```



# 哈希表

logN次扩容，每一次扩容O(N)代价，总扩容代价O（NlogN），平均单次logN

使用的时候是O（1），可以把链的长度很长，可以极大的减少扩容代价

虚拟机托管语言，可以在不在使用的时候申请替换





# 布隆过滤器

第一：样本量N

第二：失误率P

单样本的大小没有作用



多给一点内存，失误率降低



不需要删除，只需要增加查询

有一定程度的失误率（只会把白->黑，不会黑->白，可以设置到很低），不可避免





```


真实是十万分之六
```



# 一致性哈希

数据服务器怎么组织的问题

逻辑端

数据端，分布式数据库，数据怎么维持的问题

负载均衡，高频key,中频key,低频key，有没有数量来决定

​				key要选种类多的，人名，身份证号码，不适合的有国家名，性别

​				经典结构，增加机器和减少机器，数据迁移的是全量的

ip,host_name,mac address，用能区分的来做哈希值

根据哈希函数，打到环上，选择顺时针离它最近的，现在数据迁移量很少

存在问题:1.机器数量很少，就做不到一上来环数据均衡

​				 2.一旦增加或减少机器，马上负载不均衡

虚拟节点技术

​		按比例夺取，就能解决初始不均，增减不均的问题

