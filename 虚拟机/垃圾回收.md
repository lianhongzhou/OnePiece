# 对象是否存活判断算法

引用计数算法

可达性分析算法



## 可以作为GC Roots的对象

1. **虚拟机栈（栈帧中的本地变量表）中引用的对象**
2. **方法区中类静态属性引用的的对象**
3. **方法区中常量引用的对象**
4. **本地方法栈中JNI引用的对象**



## STW

由于在可达性分析的时候，如果对象引用关系还在不断变化，那么结果就无法保证了，因此必须停顿所有JAVA执行线程以实行分析工作，这个过程被称作**Stop The World,简称STW**



## OopMap

在STW时，虚拟机不用一个不漏地检查所有执行上下文和全局引用的位置，只需要检查OopMap就好了



OopMap记录了对象类型、对象偏移量，以及在特定位置记录栈和寄存器中哪些位置是引用



这些特定位置被称作安全点，  即只有到达安全点才能暂停程序



安全点选定是按程序“是否具有让程序长时间执行的特征”为标准的（如方法调用，循环跳转，异常跳转等）

，以及让所有线程都跑到安全点再停顿（使用标志位）



对于不在执行的线程（等待或者睡眠）使用安全区域，即是在一段代码片段中，引用关系不会变化的时候





# 堆回收

1. 如果用可达性算法无法到达该对象，那么该对象就会被标志第一次
2. 然后进行筛选工作，筛选的条件是此对象是否有必要执行finalize()方法（最后一次自救），如果对象没有覆盖finalize或者已经被调用过，那么他就真的死了

**NOTE:这个方法运行代价高，不确定性大，无法确保各个对象的调用顺序，所以强烈不建议使用这个方法，知道有就好了，千万不要使用（其是用于关闭外部资源的，可以用try-finally来代替）。**



# 方法区回收

## 对于常量

如果没有一个对象是引用到这个字面量，那么就会回收



## 对于类

1. 该类所有的实例都已经被回收

2. 加载该类的ClassLoader已经被回收了

3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射机制访问到该类的方法




# 垃圾回收算法

## 标记-清除算法

标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象



不足：标记清除效率低；会产生很多不连续的内存碎片



## 复制算法

将内存分为大小相等两块，每次只使用其中的一块，当一块的内存用完了，就把还存活的赋值到另一块，然后对之前那块进行清理



优点：不用考虑内存碎片问题

不足：对象存活率高时候回进行很多复制操作导致效率变低；将内存缩小为原来的一半，代价太大



## 标记-整理算法

标记回收对象，然后让存活对象向一端移动，然后回收



## 算法适用范围

在新生代里，每次垃圾回收时候都发现有大批对象死去，只有少量存活，就用复制算法

老年代里，因为对象存活率高，没有额外空间进行分配担保，必须使用“标记-清除”或“标记-整理”



# 垃圾收集器

## Serial收集器

只是用一个CPU或者一条收集线程去完成垃圾收集工作，会STW

优点：简单高效，没有线程交互的开销

适用于运行在Client模式下的虚拟机

新生代收集器，采用复制算法





## ParNew收集器

Serial收集器的多线程版本，即是使用多条线程进行垃圾收集

第一款垃圾收集的时候用户线程基本上同时工作（也就是STW时间很短）

除了Serial收集器外，唯一个能跟CMS收集器配合的

新生代收集器，使用复制算法









## Parallel Scavenge收集器

与一般收集器关注于尽可能缩短垃圾收集时用户线程的停顿时间不同，Parallel Scavenge收集器的目标是达到一个可控制的吞吐量

吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)

只需要制定目标，让虚拟机自适应调节策略完成参数调节

新生代收集器，使用复制算法







## Serial Old收集器

在JDK1.5前跟Parallel Scavenge收集器搭配

作为CMS收集器的后备预案，在并发收集发生Concurrent mode failure时使用

老年代收集器，使用“标志-整理”算法







## Parallel Old收集器

可以跟Parallel Scavenge收集器一起使用，适用于注重吞吐量以及CPU资源敏感的场合

老年代收集器，使用“标志-整理”算法





## CMS收集器

是一种以获取最短回收停顿时间为目标的收集器，适用于重视服务的相应速度，希望系统停顿时间最短，给用户较好的体验（常见的BS系统）

缺点是对CPU资源非常敏感，无法处理浮动垃圾（浮动垃圾是指在并发清理时候产生的垃圾），产生大量空间碎片

老年代收集器，使用“标记-清除”算法



运作过程分为4个阶段，

**初始标记**

​	需要STW，标记一下GC Roots能关联到的对象，速度很快，需要STW

**并发标记**

​	GC Roots Tracing的过程

**重新标记**

​	修正并发标记期间因用户程序继续运作而导致，需要STW

**并发清除**



## G1收集器

具有并行与并发

分代收集

空间整理

可预测的停顿（有计划地避免在整个JAVA堆中进行全区域的垃圾收集）

老年代收集器，采用“标记-整理”算法



运作分为4个阶段

**初始标记**

​	标记GC Roots能直接关联到的对象，修改TAMS(Next Top at Mark Start),让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象

**并发标记**

​	对堆中对象进行可达性分析，找出存活对象

**最终标记**

​	修正，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，需要把它合并到Remembered Set中（需要停顿，可停顿）

**筛选回收**

​	对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划







# GC日志理解



33.125： [GC  [DefNew: 3324K->152K(3712K)， 0.0025925 secs] 3324K->152K(11904K),0.0031680 secs]



1. 最前面的数字代表GC发生时间，是从Java虚拟机启动以来经过的秒数
2. GC和Full GC说明了这次垃圾收集的停顿类型
   - 如果有Full说明是发生了STW，一般是出现了分配担保失败的问题
   - 调用System.gc()所触发的收集在这里会显示“【Full GC(System)】”
3. DefNew是指GC发生的区域
4. 后面方括号内部是：GC前该内存区域已使用容量->GC后该内存区域已使用容量（该内存区域总容量）
5. 后面的是指，GC前JAVA堆已使用容量->GC后JAVA堆已使用容量(JAVA堆总容量)
6. 最后面的是指该内存区域GC所占用的时间





# 内存分配与回收策略

这解决了两个问题，对象分配内存以及回收分配给对象的内存





## Minor GC（新生代GC）

1. 指发生在新生代的垃圾收集动作，因为Java对象大多具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快；
2. 空间分配担保，在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间
   1. 如果成立，执行Minor GC；
   2. 如果不成立，则查看是否开启HandlePromotionFailure;
   3. 如果开启了就检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果成立，那么就进行Minor GC;
   4. 如果不成立或者没开启允许冒险的功能，那么必须进行一次Full GC.



**Note:所谓的冒险，是指新生代使用复制收集算法，为了内存利用率，只是用一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况，就需要老年代进行分配担保，把Survivor无法容纳的对象直接放入老年代。**







Minor GC触发条件：当Eden区满时，触发Minor GC。



## Major GC/Full GC(老年代GC)

指发生在老年代的GC，出现了Major GC,经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC速度一般会比Minor GC慢10倍以上。



触发条件：

1、老年代空间不足

2、方法区空间不足。

3、调用System.gc(),建议JVM进行full gc. 

4、没有足够的连续空间分配给大对象。

5、长期存活的对象转入老年代，空间不足。

6、新生代垃圾回收存活的对象太多，S1放不下，老年代担保空间不足。



## 内存分配

1. 正常情况下，对象优先在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC.

2. 大对象会直接进入老年代，所谓的大对象，是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组
3. 长期存活的对象将进入老年代。如果对象在Eden区出生并通过第一次Minor GC后仍存活，且能被Survior容纳的话，就会被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每熬过1次Minor GC，年龄就会增加1岁，当年龄大于上限的时候（MaxTenuringThreshold，默认值是15），就移动到老年代。
4. 但是，虚拟机不是永远地要求对象的年龄比如达到上限才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。







**NOTE:经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”他们，所以写程序的时候应该避免。**





# 虚拟机参数

1、-Xms20M：

　　表示设置jvm堆的最小值为20M，必须以M为单位

2、-Xmx20M：

　　表示设置JVM堆的最大值为20M，必须以M为单位。将-Xmx和-Xms设置为一样可以避免JVM内存自动扩展。大的项目-Xmx和-Xms一般都要设置

到10G、20G甚至还要高

-XX:NewSize：

　　新生代的大小

-XX:MaxNewSize：

　　最大新生代的内存大小

3、-verbose:gc：

　　表示输出虚拟机中GC的详细情况

4、-Xss128k：

　　表示可以设置虚拟机栈的大小为128k

5、-Xoss128k：

　　表示设置本地方法栈的大小为128k。不过HotSpot并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说这个参数是无效的

6、-XX:PermSize=10M：

　　表示JVM初始分配的永久代的容量，必须以M为单位

7、-XX:MaxPermSize=10M：

　　表示JVM允许分配的永久代的最大容量，必须以M为单位，大部分情况下这个参数默认为64M

-XX:MetaspaceSize=：

　　Metaspace默认大小

-XX:MaxMetaspaceSize=：

　　Metaspace最大空间大小

-XX:+UseCompressedClassPointers：

　　启用压缩的类指针，也就是32位，+启动，-关闭

-XX:+InitialCodeCacheSize：

　　CodeCache初始大小

-XX:+ReservedCodeCacheSize：

　　CodeCache最大内存

-XX:+CompressedClassSpaceSize：

　　启动了CCS，才会有这部分空间

8、-Xnoclassgc：

　　表示关闭JVM对类的垃圾回收

9、-XX:+TraceClassLoading：

　　表示查看类的加载信息

10、-XX:+TraceClassUnLoading：

　　表示查看类的卸载信息

11、-XX:NewRatio=4：

　　表示设置年轻代：老年代的大小比值为1：4，这意味着年轻代占整个堆的1/5

12、-XX:SurvivorRatio=8：

　　表示设置2个Survivor区：1个Eden区的大小比值为2:8，这意味着Survivor区占整个年轻代的1/5，这个参数默认为8

13、-Xmn20M：

　　表示设置年轻代的大小为20M

14、-XX:+HeapDumpOnOutOfMemoryError：

　　表示可以让虚拟机在出现内存溢出异常时Dump出当前的堆内存转储快照

15、-XX:+UseG1GC：

　　表示让JVM使用G1垃圾收集器

16、-XX:+PrintGCDetails：

　　表示在控制台上打印出GC具体细节

17、-XX:+PrintGC：

　　表示在控制台上打印出GC信息

18、-XX:PretenureSizeThreshold=3145728：

　　表示对象大于31457283M、时直接进入老年代分配，这里只能以字节作为单位

19、-XX:MaxTenuringThreshold=1：

　　表示对象年龄大于1，自动进入老年代

-XX:TargetSurvivorRatio：

　　如果进行进行一次GC存活的对象超过这个参数，会计算相同年龄所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象

就可以直接进入老年代，无须等到MaxTenuringThreshold要求的年龄

-XX:PringTenuringDistribution：

　　对象发生晋升的时候，打印堆中各个对象的年龄

20、-XX:CompileThreshold=1000：

　　表示一个方法被调用1000次之后，会被认为是热点代码，并触发即时编译

21、-XX:+PrintHeapAtGC：

　　表示可以看到每次GC前后堆内存布局

22、-XX:+PrintTLAB：

　　表示可以看到TLAB的使用情况

23、-XX:+UseSpining：

　　开启自旋锁

24、-XX:PreBlockSpin

　　更改自旋锁的自旋次数，使用这个参数必须先开启自旋锁