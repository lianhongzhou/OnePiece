# 锁消除

## 定义

是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。



## 出现时机

即是编译器运行时





## 逃逸分析

逃逸分析的基本行为就是分析对象动态作用于：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，例如赋值给类变量或者在其他线程中访问的实例变量，称为线程逃逸。

优化操作：栈上分配，同步消除，标量替换





### 判定依据

逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把他们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。



## 锁消除经典例子

```java
public String concatString(String s1, String s2,String s3){
    return s1+s2+s3;
}
```





# 锁粗化

​		原则上,我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小-只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。

​		大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

​		如果虚拟机探测到有这样零碎的操作都对统一对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列的外部。

```java
//原始代码
for(int i=0;i<size;i++){
    synchronized(lock){
    }
}

//锁粗化后真实代码
for(int i=0;i<size;i++){
    synchronized(lock){
    }
}
```

