# 内存泄漏排查方法

1. 先用jps命令查找正在运行的虚拟机进程

2. 然后用jstat监视进程垃圾收集信息，jstat -gcutil 进程号 间隔毫秒数，ie, jstat -gcutil 12538 5000

   jstat -gccause 进程号，最近一次GC统计和原因

3. 用jstack命令保存栈现场，jmap保存堆信息

   jstack +进程号

   jmap -heap pid 打印出堆概要信息

   jmap -histo [pid]打印出所有对象

   jmap -dump format=b file=路径

   -[XX](https://www.baidu.com/s?wd=XX&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao):+HeapDumpOnOutOfMemoryError -[XX](https://www.baidu.com/s?wd=XX&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao):HeapDumpPath=${目录}。

4. 然后用jvisualvm分析dump文件



备注：如果linux下是通过yum安装的话，是没有开发者工具的，需要另外安装，需java-1.X.X-openjdk-devel这个包

# 高性能硬件上的程序部署策略

## 方法选择

在高性能硬件上部署程序，主要采用：

1. 通过64位JDK来使用大内存

2. 使用若干个32位虚拟机建立逻辑集群来利用硬件资源





## 64位JDK的困扰

若使用64位JDK管理大内存，会面临问题：

1. 内存回收导致的长时间停顿；
2. 64位JDK性能比32位弱；
3. 需要程序足够稳定，这种应用要是产生堆溢出就无法产生对转储快照（会有十几G乃至更大的dump文件），哪怕产生了快照也几乎无法进行分析；
4. 相同程序在64位JDK消耗的内存一般比32位JDK大，这是由于指针膨胀，数据类型对齐补白等因素导致的。





## 集群操作

1. 在一台物理机器上启动多个应用服务器程序，每个服务器进程分配不同端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。
2. 在一台物理机器上建立逻辑集群的目的仅仅是为了尽可能利用硬件资源，所以使用无session复制的亲和式集群（也就是按session ID将一个固定用户请求分配到集群结点处理）





## 集群的缺点

1. 避免结点竞争全局资源，最典型的是磁盘竞争，各个节点如果同时访问某个磁盘文件，就很容易导致IO异常
2. 很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余（可以用集中式的JNDI，有一定复杂性并且会带来额外的性能开销）
3. 各个节点不可避免地收到32位内存限制，在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多开到1.5GB(在其他系统中也最多接近4GB，始终收到32位的限制)
4. 大量使用本地缓存的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，此时可以考虑把本地缓存改为集中式缓存







# 集群间同步导致的内存溢出

​	JBossCache是基于自家的JGroups进行集群间的数据通信，JGroups使用协议栈的方式来实现首发数据包的各种所需特性自由组合，数据包接收和发送要经过每层协议栈的up()和down()方法，其中的NAKACK栈用于保障各个包的有效顺序及重发。

​	由于信息有传输失败需要重发的可能性，在确认所有注册在GMS的节点都收到正确的信息前，发送的信息必须必须在内存中保留。当网络情况不能满足传输要求得时候，重发数据在内存不断堆积，就产生内存溢出。







# 堆外内存导致的溢出错误

直接内存区只能等老年代满了后Full GC,然后顺便的清理掉

否则的话只能等抛出内存溢出异常的时候，先catch,然后在system.gc(),如果这个时候虚拟机开启了禁止调用system.gc（）的参数的话，那么就会内存溢出







# 外部系统命令导致系统缓慢

Java调用外部Shell脚本获取系统信息，虽然外部命令本身能很快执行完毕，但是频繁调用时创建进程的开销也非常可观。







# 服务器JVM进程崩溃

远程断开连接异常



​				由于MIS系统用户多，待办事项变化很快，为了不被OA系统速度拖累，使用了异步方式调用Web服务，但由于服务速度完全不对等，时间久了太多Web服务器没有调用成功，导致在等待的线程和Socket连接越来越多，最多超过虚拟机的承受能力导致虚拟机进程崩溃。



解决方法：将异步调用改为生产者/消费者模式的消息队列实现





# 不恰当数据结构导致内存占用过大



